- Reprendre le but du projet : pourquoi on fait ça ? Qu'est-ce qu'on fait ?
	Système de gestion des cheptels vifs au niveau national.
	Spécification sur les animaux (poids maturité, nombre par enclos, etc)
- Attente du projet : MOE
	Gestion d'un cheptel vif avec interface utilisateur (cas d'utilisation ici).
	Différents cas : administrateur ou utilisateur. 
- Contraintes techniques : Linux, Java, MySQL
- Diagramme de classe
- Tests d'intégration
	- Toutes les infos sont modélisées
	- Tout utilisateur a le droit de consulter les données, et d’utiliser les fonctions de recherche.
	- Seul l’Administrateur des nomenclatures peut modifier les nomenclatures.
	- Chaque éleveur peut déclarer une nouvelle tête et enregistrer les évènements qui lui sont associés. Lors de la déclaration d’une nouvelle tête, un numéro d’identification national est généré automatiquement et attribué au nouveau candidat.


- MOE : organisation temporelle, de l'équipe
	- Diagramme de Gantt, OBS
	- Relation MOA-MOE (date de rendu, livraisons, réponses, etc)
- Mise en place de la gestion des anomalies
- WebService
	- Accès à la base de données (visualisation, ajout de bêtes, etc)
- tests unitaires, MySQL, ANT

--Conrad
Bonjour à tous. Nous allons vous présenter le projet que nous avons suivi lors de ce semestre : la création d'un système de gestion d'un cheptel vif. Nous allons tout d'abord vous présenter le cadre dans lequel se place ce projet. Nous verrons ensuite les différentes contraintes qu'implique ce projet. De plus, nous vous présenterons l'organisation que nous avons mis en place, et enfin, les différentes techniques mises en place lors de l'implémentation.
 Comme je viens de le dire, nous allons tout d'abord vous présenter le but de ce projet. La maîtrise d'ouvrage, disons par exemple un rassemblement d'exploitants, souhaitrait créer un système de gestion de cheptel vif. En effet, cette gestion peut vite devenir complexe si on désire étendre la gestion du bétail à plusieurs exploitations ou si on souhaite aggrandir le nombre de bêtes à disposition. Un cheptel bien géré doit être connu et maîtrisé, afin d'avoir des résultats satisfaisants et une rentabilité maximale.
A titre d'exemple, les animaux sont vendus entre 8 mois et 1 an, à un poids qui avoisine les 3.5kg. On distingue deux types d'animaux : les animaux destinés à être vendus et les animaux servant à la reproduction. On doit penser également à l'enclos, qui ne doit pas forcément contenir trop d'animaux en même temps. On estime qu'un enclos ne peut contenir plus de 10 adultes ou 15 jeunes. On doit aussi penser à la castration vers les 2 ou 3 mois si on veut élever plusieurs males ensemble.
Enfin, tous ces animaux sont reconnu par différents marqueurs : un numéro d'identification, un nom d'espèce, un sexe, et d'autres encore. Enfin, tout type d'évènement survenant avec chaque animal doit être répertorié afin d'assurer un tracé régulier des animaux.
Bien sûr, ce programme étant destiné à des personnes n'étant pas forcément informaticiens, il doit être accessible à des utilisateurs n'ayant que des connaissances de base en informatique. (C'EST CLAIR)
A présent, Anca va vous présenter les différentes contraintes techniques que peuvent imposer ce type de projet.

--Anca
Avec ce qui nous a été demandé par la maîtrise d'ouvrage, différentes contraintes technique se dégagent. On doit, bien évidemment, s'imposer plusieurs contraintes techniques. Les systèmes d'exploitation suportés reposeront, dans un premier temps, sur Linux. On choisit de plus le langage de programmation Java pour toutes les possibilités qu'il offre. En effet, étant donné qu'on souhaite avoir une application accessible à un maximum de personnes, les bibliothèques qu'offrent ce langage nous assureront un développement rapide répondant aux besoins.
Il est évident que ce projet impose la gestion d'une base de données, ne serait-ce que pour organiser la façon dont toutes les bêtes sont enregistrées. On utilise donc le MySQL pour gérer facilement cette base, dont le lien avec le Java peut facilement être assuré. Enfin, l'architecture sera distribuée et orientée service (sérieusement, ça veut dire quoi ça ?)
Bien sûr, avant tout développement, nous pouvons de suite penser aux différents tests d'intégration qui seront mis en place. Cela se placera surtout au niveau de la gestion de la base de données, et sera surtout une question de sécurité. Un module d'authentification, qui sera nécessaire, devra être longuement testé, et permettre de différencier un administrateur de la base de donnée et un simple utilisateur. Enfin, selon le profil accédant à la base de données, on doit pouvoir au choix :
	- créer
	- consulter
	- modifier
	- supprimer
un élément de cette base. L'interface de gestion sera définie par un modèle, qui pourra éventuellement être quelque peu changé par la maîtrise d'oeuvre après accord avec la maîtrise d'ouvrage.
Pour finir, on va définir le cycle de développement du programme, qui sera une suite de cycle en V. Après l'analyse des besoins et la définition de spécifications, que nous avons déjà explicité, nous passerons à la conception architecturale. Une batterie de tests doit être bien évidement défini en parallèle. On passe par la suite à la conception détaillée, qui sera la définition de tous nos algorithmes, avec en parallèle la définition des tests unitaires. Enfin, on passera au codage de nos algorithmes. Si tous les tests sont validés, on déclare le module comme fonctionnel et on recommence le même cycle avec le module suivant.
A présent, Alexandre va vous parler de l'organisation de la maîtrise d'oeuvre.

--WAM
Il est clair (C'EST CLAIR) qu'afin que ce projet soit mené au bout, il doit être organisé, aussi bien temporellement que structurellement. Il existe pour cela différentes techniques qui facilitent l'organisation des projets. Si on prend l'organisation temporelle, il est important de bien définir les différentes tâches et surtout de définir l'ordre dans lesquelles elles interviennent et le temps qu'elles vont prendre. Différents logiciels existent pour nous aider à définir de manière optimal l'ordre dans lequel ces tâches seront effectuéesOn peut citer l'exemple de GanttProject, qui nous aide à bien définir nos tâches correctement. On peut ainsi définir les différentes tâche ainsi que leur longueur ainsi que les prédécesseurs. Le logiciel nous fournir ainsi un diagramme de Gantt qui nous donne toutes nos phases.
L'estimation du temps alloué à chaque phase reste cependant quelque chose de compliqué. En effet, il est difficile de savoir combien de temps nous pouvons allouer à des tâches dont nous ne savons pas forcément au début tous les problèmes qu'ils pourront poser, ou au contraire la facilité avec laquelle on va résoudre le problème le moment venu. Il existe pour cela des méthodes d'estimation des efforts à fournir en fonction d'une estimation des lignes de codes à écrire, méthode appellée COCOMO pour COnstructive COst MOdel.
L'organisation structurelle se fait elle par un diagramme OBS, pour Organization Breakdown Structure. Ce diagramme permet d'organiser l'équipe et de dispatcher les tâches entre ses membres. Les diagrammes OBS se présentent sous forme d'une aborescence les différents composants de travail nécessaire pour à réaliser les différents composants de notre projet. Dans notre groupe, j'étais chef de projet et donc chargé de la supervision des tâches ainsi que de la relation avec le client. Anca se chargeait de la qualité et des tests. Conrad se chargeait du codage du côté Java et Pascal du côté SQL.
Bien entendu, la structuration ne se fait pas uniquement du côté maître d'oeuvre mais aussi dans sa relation avec le maître d'ouvrage qui devra s'organiser. Ainsi, les relations MOE et MOA sont bien définies à l'avance. On introduit ainsi la notion de fini du produit rendu : chaque rendu devra intégrer un dossier d'analyse fonctionnelle et conceptuelle, accompagné des codes sources, des tests avec leurs rapports, d'une revue de l'application et d'une retrospective. A partir du rendu, le client a une semaine pour donner sa réponse, ce qu'on appelle la recette. La recette contient des fiches d'anomalie ainsi qu'un procès verbal signés aussi bien par le MOE et le MOA donnant l'acceptation ou le rejet du projet. Bien entendu, le MOE et le MOA s'engagent à respecter tous deux les différents plannings.
Pour finir, Pascal va nous présenter les différentes techniques mises en place lors des différentes phases d'implémentation.

--Pascal
Tout d'abord, comme nous l'avons précisé plus tôt, l'application doit être utilisable le plus facilement possible. Comme nous l'avaons aussi précisé, le développement se fait en Java pour la partie interface et en SQL pour la partie base de données. Nous aurons donc besoin de faire une connexion entre SQL et Java, ce qui se fait assez facilement dans ce magnifique langage qu'est le Java avec une bibliothèque bien choisie. (C'EST CLAIR)
Le deuxième problème est donc de faire une interface pour accéder facilement à la base de données, en respectant les contraintes de sécurité données plus haut. Là encore, le Java est magnifique, car avec une bibliothèque bien choisie, nous pouvons faire ce qu'on appelle un WebService. Ceci correspond à un service accessible via un navigateur web tel que Internet Explorer et publié sur un serveur grâce à la Java Machine. Chaque connexion à ce serveur déclenche ainsi une suite de message, qu'on peut exploiter pour définir le service qu'on souhaite fair epour notre gestion de base de données.
D'un point de vue à présent plus pragmatique, un projet de cette ampleur nécessite néanmoins une grande organisation même au niveau de l'implémentation. Comme dit précédemment, toute une batterie de tests doit être écrit pour valider chaque module. Les tests unitaires, définis lors de la spécification, peuvent être facilement intégrer au développement (dans ce magnifique langage qu'est le Java) en JAVA grâce à JUnit, qui permet d'automatiser la définition des tests ainsi que leur exécution et leur validation.
Enfin, le rendu d'un module est définie de manière très précise. Ainsi, afin de ne rien oublier, on peut automatiser les tâches au moyen de ANT. Ainsi, grâce à un fichier XML, on peut demander à faire en un seul clic (de feignasse) la compilation, la création d'un jar, la documentation -par la Javadoc- ou même la création d'un zip contenant tout cela pour l'envoyer directement au client. On assure ainsi la qualité du rendu, et cela en un temps record. (Et comme on dit chez les néerlandais, le temps c'est de l'argent.)

Merci pour votre attention.
